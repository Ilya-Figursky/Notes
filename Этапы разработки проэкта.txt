
Шаг 2: База данных и EF Core (2-3 вечера)
Ресурс: Метанит, Глава 12.

Создай класс Note (Id, Title, Content, CreatedAt).

Подключи Entity Framework Core и драйвер Npgsql (для Postgres) через NuGet.

Настрой DbContext и строку подключения в appsettings.json.

Сделай Migration (создание таблиц) и Update-Database.

Задача: Убедись через pgAdmin, что таблица в базе создалась.

Шаг 3: CRUD операции (Основа работы) (3-4 вечера)
Реализуй методы в контроллере:

GET /api/notes (получить все)

GET /api/notes/{id} (получить одну)

POST /api/notes (создать)

PUT /api/notes (обновить)

DELETE /api/notes/{id} (удалить)

Важно: Сначала пиши код прямо в контроллере. Когда заработает — вынеси логику в Сервис (NotesService), а контроллер пусть только вызывает сервис. Это и есть то самое "Dependency Injection" (Глава 3).

Шаг 4: Валидация и обработка ошибок (1-2 вечера)
Что если при создании заметки не передали заголовок?

Добавь библиотеку FluentValidation (как на твоей схеме) или используй стандартные атрибуты [Required].

Сделай так, чтобы API возвращал 400 Bad Request, если данных нет, и 404 Not Found, если заметка не найдена.

Шаг 5: Аутентификация (Самое сложное) (3-4 вечера)
Ресурс: Метанит, Глава 13 (JWT).

Добавь таблицу User (Login, PasswordHash).

Сделай контроллер AuthController с методом Login, который возвращает JWT токен.

Поставь атрибут [Authorize] на свои заметки. Теперь Swagger должен требовать замочек (токен) для доступа.

Сделай так, чтобы при запросе заметок юзер видел только свои заметки (фильтрация по UserId из токена).

Шаг 6: Публикация на GitHub
Это твое лицо. Код должен быть там.

Сделай красивый README.md. Напиши там: "Технологии: C#, ASP.NET Core, EF Core, PostgreSQL. Реализован REST API с JWT авторизацией".